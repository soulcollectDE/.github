name: Reusable - Dependabot Auto-Triage (Improved)

on:
  workflow_call:
    inputs:
      repo:
        required: true
        type: string
      fail_on_intersection:
        description: "Fail when (unused ∩ alerts) not empty"
        type: boolean
        default: false
      min_severity:
        description: "only triage alerts >= (low|moderate|medium|high|critical)"
        type: string
        default: "low"

      include_npm:
        type: boolean
        default: true
      include_yarn:
        type: boolean
        default: true
      include_pnpm:
        type: boolean
        default: true

      include_pip:
        type: boolean
        default: true
      include_poetry:
        type: boolean
        default: false
      include_conda:
        type: boolean
        default: false

      include_composer:
        type: boolean
        default: true

      include_maven:
        type: boolean
        default: false
      include_gradle:
        type: boolean
        default: false
      include_ivy:
        type: boolean
        default: false

      include_cargo:
        type: boolean
        default: false

      include_nuget:
        type: boolean
        default: false

      include_go:
        type: boolean
        default: true

      include_rubygems:
        type: boolean
        default: false


    secrets:
      security_token:
        required: false

permissions:
  contents: read
  security-events: read

concurrency:
  group: depauto-${{ inputs.repo }}
  cancel-in-progress: false

jobs:
  triage:
    name: Triage ${{ inputs.repo }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: read
      issues: write
      pull-requests: write
    env:
      REPO: ${{ inputs.repo }}
      GH_TOKEN: ${{ secrets.security_token || github.token }}
      MIN_SEVERITY: ${{ inputs.min_severity }}

    steps:
    # 1) Checkout target repo (zu scannendes Repo)
      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.REPO }} #arbeit auf caller repo
          fetch-depth: 0

    # 2) Checkout dieses (Workflow-)Repo für die Skripte
      - name: Checkout workflow scripts
        uses: actions/checkout@v4
        with:
          path: .automation
          fetch-depth: 1

    # 3) Make scripts executable
      - name: Make scripts executable
        run: chmod +x .automation/.github/scripts/*


#sbom nutzen ?

    
    # 4) Discover manifests -> writes manifests.json
      - name: Discover manifests (monorepo aware)
        id: discover
        env:
          INCLUDE_NPM: ${{ inputs.include_npm }}
          INCLUDE_YARN:   ${{ inputs.include_yarn }}
          INCLUDE_PNPM:   ${{ inputs.include_pnpm }}
          INCLUDE_PIP: ${{ inputs.include_pip }}
          INCLUDE_POETRY: ${{ inputs.include_poetry }}
          INCLUDE_CONDA:  ${{ inputs.include_conda }}
          INCLUDE_COMPOSER: ${{ inputs.include_composer }}
          INCLUDE_MAVEN: ${{ inputs.include_maven }}
          INCLUDE_GRADLE: ${{ inputs.include_gradle }}
          INCLUDE_IVY:    ${{ inputs.include_ivy }}
          INCLUDE_CARGO:  ${{ inputs.include_cargo }}
          INCLUDE_NUGET:  ${{ inputs.include_nuget }}
          INCLUDE_GO:     ${{ inputs.include_go }}
          INCLUDE_RUBYGEMS:     ${{ inputs.include_rubygems }}

        shell: bash
        run: .automation/.github/scripts/discover_manifests.sh

    # 5) Build matrix based on discovered manifests.json
    #steps.matrix.outputs.matrix enthält die JSON-Matrix
      - name: Build work matrix
        id: matrix
        shell: bash
        run: .automation/.github/scripts/build_matrix.sh

    # 6) Ecosystem-specific setup
      # ───────────────────────── JS/TS: npm, yarn, pnpm ─────────────────────────
      - name: Setup Node (npm/yarn/pnpm)
        if: contains(steps.matrix.outputs.matrix, '"type":"npm"') ||
            contains(steps.matrix.outputs.matrix, '"type":"yarn"') ||
            contains(steps.matrix.outputs.matrix, '"type":"pnpm"')
        uses: actions/setup-node@v4
        with:
            node-version: '20'
            # Grundsätzlich 'npm' cachen; yarn/pnpm bekommen bei Bedarf eigene Caches unten
            cache: 'npm'

      - name: Enable Corepack (for yarn/pnpm)
        if: contains(steps.matrix.outputs.matrix, '"type":"yarn"') ||
            contains(steps.matrix.outputs.matrix, '"type":"pnpm"')
        run: corepack enable

        # Optional: dedizierte Caches
      - name: Setup yarn cache
        if: contains(steps.matrix.outputs.matrix, '"type":"yarn"')
        uses: actions/setup-node@v4
        with:
            node-version: '20'
            cache: 'yarn'

      - name: Setup pnpm cache
        if: contains(steps.matrix.outputs.matrix, '"type":"pnpm"')
        uses: actions/setup-node@v4
        with:
            node-version: '20'
            cache: 'pnpm'

        # ───────────────────────── Python: pip, poetry, conda ─────────────────────
      - name: Setup Python (pip/poetry baseline)
        if: contains(steps.matrix.outputs.matrix, '"type":"pip"') ||
            contains(steps.matrix.outputs.matrix, '"type":"poetry"')
        uses: actions/setup-python@v5
        with:
            python-version: '3.11'
            cache: 'pip'
            cache-dependency-path: |
                **/requirements.txt

        # Poetry Tool (nur wenn gebraucht)
      - name: Install Poetry
        if: contains(steps.matrix.outputs.matrix, '"type":"poetry"')
        run: |
            python -m pip install --upgrade pip
            pip install poetry

        # Conda-Umgebung (separat, da eigener Installer)
      - name: Setup Miniconda (conda)
        if: contains(steps.matrix.outputs.matrix, '"type":"conda"')
        uses: conda-incubator/setup-miniconda@v3
        with:
            auto-activate-base: false
            # Optional: eine default Env erzeugen, das eigentliche environment.yml
            # wird später im Scan-Schritt pro Projekt eingespielt.
            python-version: "3.11"

        # ───────────────────────── PHP: Composer ──────────────────────────────────
      - name: Setup Composer
        if: contains(steps.matrix.outputs.matrix, '"type":"composer"')
        run: |
            sudo apt-get update -y
            sudo apt-get install -y composer

        # ───────────────────────── JVM: Maven, Gradle, Ivy ────────────────────────
      - name: Setup Maven
        if: contains(steps.matrix.outputs.matrix, '"type":"maven"')
        uses: stCarolas/setup-maven@v4
        with:
            maven-version: '3.9.8'

        # Gradle: meist via Wrapper ./gradlew; falls kein Wrapper → globales Gradle
      - name: Setup Gradle (if needed)
        if: contains(steps.matrix.outputs.matrix, '"type":"gradle"')
        uses: gradle/actions/setup-gradle@v3

        # Ivy benötigt i. d. R. Ant/Java; wir stellen nur Java bereit
      - name: Setup Java for Ivy
        if: contains(steps.matrix.outputs.matrix, '"type":"ivy"')
        uses: actions/setup-java@v4
        with:
            distribution: temurin
            java-version: '17'

        # ───────────────────────── Rust: Cargo ────────────────────────────────────
      - name: Setup Rust (Cargo)
        if: contains(steps.matrix.outputs.matrix, '"type":"cargo"')
        uses: dtolnay/rust-toolchain@stable
        with:
            toolchain: stable
            components: ""
            targets: ""

        # ───────────────────────── .NET: NuGet ────────────────────────────────────
      - name: Setup .NET SDK (NuGet)
        if: contains(steps.matrix.outputs.matrix, '"type":"nuget"')
        uses: actions/setup-dotnet@v4
        with:
            dotnet-version: '8.0.x'

        # ───────────────────────── Go: Modules ────────────────────────────────────
      - name: Setup Go
        if: contains(steps.matrix.outputs.matrix, '"type":"go"')
        uses: actions/setup-go@v5
        with:
            go-version: '1.22.x'

        # ───────────────────────── Ruby: Bundler/RubyGems ─────────────────────────
      - name: Setup Ruby (RubyGems/Bundler)
        if: contains(steps.matrix.outputs.matrix, '"type":"rubygems"')
        uses: ruby/setup-ruby@v1
        with:
            ruby-version: '3.3'
            bundler-cache: false  # Cache kann später pro Projekt aktiviert werden

    #7) Arbeitsordner für alle Scan Resultate vorbereiten
        #dummy-Datei, damit der Ordner auch bei leerem Scan erhalten bleibt
      - name: Prepare triage dir
        shell: bash
        run: |
            mkdir -p triage/sub
            touch triage/_touch 

    # 8) Scan der ProjMatrix aus 6) (jeweils in Unterordner triage/sub/...) 
            #also hier dep check -> ai ? -> wie lang ? 
            #*_used und *_unused.txt
      - name: Scan subprojects (matrix-like loop)
        shell: bash
        env:
          MATRIX_JSON: ${{ steps.matrix.outputs.matrix }}
        run: .automation/.github/scripts/scan_subprojects.sh

    # 9) Check Konto/Repo access -> wegen alerts checkout + mini check auf security-events: read
      - name: Who am I & can I see the repo?
        shell: bash
        run: .automation/.github/scripts/whoami_repo.sh

    # 10) Alerts sammeln -> in alerts.json speichern für klassifizierung
      - name: Fetch Dependabot alerts (open→all→GraphQL) with severity filter
        env:
          REPO: ${{ inputs.repo }}
          MIN_SEVERITY: ${{ inputs.min_severity }}
        shell: bash
        run: python .automation/.github/scripts/fetch_alerts.py

    # 11)
      - name: Classify & intersect (dev/runtime, used/unused)
        shell: bash
        run: python .automation/.github/scripts/classify_intersect.py










      - name: Build report
        id: report
        shell: bash
        env:
          MIN_SEVERITY: ${{ inputs.min_severity }}
        run: .automation/.github/scripts/build_report.sh

      - name: Comment to PR (if PR)
        if: ${{ github.event_name == 'pull_request' }}
        uses: thollander/actions-comment-pull-request@v2
        with:
          filePath: triage/report.md

      - name: Mirror kept alerts to Issues (dedup)
        env:
          DEST_REPO: ${{ env.REPO }}
        shell: bash
        run: python .automation/.github/scripts/mirror_kept_to_issues.py

      - name: Sanitize artifact name
        id: sanitize
        shell: bash
        run: .automation/.github/scripts/sanitize_name.sh

      - name: Upload triage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: triage-${{ steps.sanitize.outputs.safe }}
          path: triage/**

      - name: Fail on intersections (policy)
        if: ${{ inputs.fail_on_intersection == true }}
        shell: bash
        run: .automation/.github/scripts/fail_on_intersections.sh
