name: Reusable - Dependabot Auto-Triage (Improved)

on:
  workflow_call:
    inputs:
      repo:
        required: true
        type: string
      fail_on_intersection:
        description: "Fail when (unused ∩ alerts) not empty"
        type: boolean
        default: false
      min_severity:
        description: "only triage alerts >= (low|moderate|medium|high|critical)"
        type: string
        default: "low"
      include_node:
        type: boolean
        default: true
      include_python:
        type: boolean
        default: true
      include_composer:
        type: boolean
        default: true
      include_maven:
        type: boolean
        default: false   # optional: kann teuer sein
    secrets:
      security_token:
        required: false

concurrency:
  group: depauto-${{ inputs.repo }}
  cancel-in-progress: false

jobs:
  triage:
    name: Triage ${{ inputs.repo }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: read
      issues: write
      pull-requests: write
    env:
      REPO: ${{ inputs.repo }}
      GH_TOKEN: ${{ secrets.security_token || github.token }}

    steps:
      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.REPO }}
          fetch-depth: 0

      - name: Discover manifests (monorepo aware)
        id: discover
        shell: bash
        run: |
          set -euo pipefail
          prune='-path "./.git" -prune -o -path "*/node_modules/*" -prune -o -path "*/vendor/*" -prune -o -path "*/.venv/*" -prune -o -path "*/venv/*" -prune -o -path "*/build/*" -prune -o -path "*/dist/*" -prune -o -path "*/target/*" -prune'

          node_paths="[]"
          py_paths="[]"
          comp_paths="[]"
          maven_paths="[]"

          if ${{ inputs.include_node }}; then
            node_paths=$(bash -lc "find . $prune -o -name package.json -print | xargs -I{} dirname {} | sort -u | jq -R . | jq -s .")
          fi
          if ${{ inputs.include_python }}; then
            py_paths=$(bash -lc "find . $prune -o -name requirements.txt -print | xargs -I{} dirname {} | sort -u | jq -R . | jq -s .")
          fi
          if ${{ inputs.include_composer }}; then
            comp_paths=$(bash -lc "find . $prune -o -name composer.json -print | xargs -I{} dirname {} | sort -u | jq -R . | jq -s .")
          fi
          if ${{ inputs.include_maven }}; then
            maven_paths=$(bash -lc "find . $prune -o -name pom.xml -print | xargs -I{} dirname {} | sort -u | jq -R . | jq -s .")
          fi

          jq -n \
            --argjson node "$node_paths" \
            --argjson py "$py_paths" \
            --argjson comp "$comp_paths" \
            --argjson maven "$maven_paths" \
            '{node:$node, python:$py, composer:$comp, maven:$maven}' > manifests.json
          cat manifests.json

      - name: Build work matrix
        id: matrix
        shell: bash
        run: |
          set -euo pipefail
          items=$(jq -c '
            ([.node[]? | {type:"node", path:.}] // []) +
            ([.python[]? | {type:"python", path:.}] // []) +
            ([.composer[]? | {type:"composer", path:.}] // []) +
            ([.maven[]? | {type:"maven", path:.}] // [])
          ' manifests.json)

          if [ -z "$items" ] || [ "$(jq 'length' <<<"$items")" -eq 0 ]; then
            items='[{"type":"none","path":"."}]'
          fi

          echo "matrix={\"include\":$(echo "$items")}" >> $GITHUB_OUTPUT
          jq -r <<< "{\"include\": $items}"

      - name: Setup Node (with cache)
        if: contains(steps.matrix.outputs.matrix, '"type":"node"')
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup Python (with cache)
        if: contains(steps.matrix.outputs.matrix, '"type":"python"')
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: |
            **/requirements.txt

      - name: Setup Composer (optional)
        if: contains(steps.matrix.outputs.matrix, '"type":"composer"')
        run: |
          sudo apt-get update -y
          sudo apt-get install -y composer

      - name: Setup Maven (optional)
        if: contains(steps.matrix.outputs.matrix, '"type":"maven"')
        uses: stCarolas/setup-maven@v4
        with:
          maven-version: '3.9.8'

      - name: Prepare triage dir
        run: mkdir -p triage/sub && echo > triage/_touch

      - name: Scan subprojects (matrix-like loop)
        shell: bash
        run: |
          set -euo pipefail
          jq -c '.include[]' <<< '${{ steps.matrix.outputs.matrix }}' | nl -ba | while read -r idx line; do
            type=$(jq -r '.type' <<<"$line")
            path=$(jq -r '.path' <<<"$line")
            echo "::group::Scan [$idx] $type @ $path"
            case "$type" in
              node)
                pushd "$path" >/dev/null
                # install minimal, tolerant
                if [ -f package-lock.json ]; then npm ci --silent || npm install --silent || true; else npm install --silent || true; fi
                npx --yes depcheck --json > depcheck.json || echo '{}' > depcheck.json
                # USED korrekt aus 'using'
                jq -r '(.using // {}) | keys[]?' depcheck.json | sort -u > ../..//triage/sub/${idx}_node_used.txt || true
                # UNUSED (für Schnittmenge)
                jq -r '((.dependencies // []) + (.devDependencies // []))[]?' depcheck.json | sort -u > ../..//triage/sub/${idx}_node_unused.txt || true
                popd >/dev/null
                ;;
              python)
                pushd "$path" >/dev/null
                python -m pip install --upgrade pip >/dev/null
                pip install -r requirements.txt >/dev/null || true
                pip install pip-check-reqs >/dev/null
                (pip-extra-reqs . || true) | awk '/^\*/{print $2}' | sed 's/==.*//' | sort -u > ../..//triage/sub/${idx}_py_extra.txt || true
                popd >/dev/null
                ;;
              composer)
                pushd "$path" >/dev/null
                composer -n install || true
                composer global require composer-unused/composer-unused --no-interaction || true
                composer-unused --format=json > comp_unused.json || echo '{"unused":[]}' > comp_unused.json
                jq -r '.unused[]?' comp_unused.json | sort -u > ../..//triage/sub/${idx}_comp_unused.txt || true
                popd >/dev/null
                ;;
              maven)
                pushd "$path" >/dev/null
                mvn -q -DskipTests dependency:analyze -DfailOnWarning=false || true
                # Log-Zeilen mit "Unused declared dependencies found:" → Artefakt ableiten
                # (heuristisch; Maven-Plugin wechselt gelegentlich Format)
                grep -E "Unused declared dependencies found:" -A9999 target/*/build.log 2>/dev/null \
                  | awk '/^\[INFO\]/{print $3}' | sed 's/://g' | sort -u > ../..//triage/sub/${idx}_mvn_unused.txt || true
                popd >/dev/null
                ;;
              none)
                true
                ;;
            esac
            echo "::endgroup::"
          done

      - name: Who am I & can I see the repo?
        run: |
          gh auth status
          gh api -i repos/${{ env.REPO }} | head -n 20 || true

      - name: Fetch Dependabot alerts (open→all→GraphQL) with severity filter
        env:
          REPO: ${{ inputs.repo }}
          MIN_SEV: ${{ inputs.min_severity }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p triage
          python << 'PY'
          import os, json, subprocess

          REPO = os.environ["REPO"]
          MIN = (os.environ.get("MIN_SEV") or "low").lower()
          rank = {"low":1,"moderate":2,"medium":2,"high":3,"critical":4}
          min_r = rank.get(MIN,1)

          def rscore(s): return rank.get((s or "").lower(),0)
          def sh(*a): return subprocess.run(a, capture_output=True, text=True)

          def try_rest(state):
            r = sh("gh","api","-H","Accept: application/vnd.github+json",
                   "-H","X-GitHub-Api-Version: 2022-11-28",
                   f"repos/{REPO}/dependabot/alerts?state={state}&per_page=100","--paginate")
            if r.returncode!=0: return []
            try: arr = json.loads(r.stdout or "[]")
            except: arr=[]
            return [a for a in arr if rscore(a.get("severity") or (a.get("security_advisory") or {}).get("severity"))>=min_r]

          def try_graphql():
            q = """
            query($owner:String!,$name:String!,$after:String){
              repository(owner:$owner,name:$name){
                vulnerabilityAlerts(first:100, after:$after){
                  pageInfo{ hasNextPage endCursor }
                  nodes{
                    vulnerableManifestPath
                    securityVulnerability{
                      severity
                      package{ name ecosystem }
                      advisory{ ghsaId summary identifiers{ type value } }
                      vulnerableVersionRange
                    }
                  }
                }
              }
            }"""
            owner,name = REPO.split("/",1)
            after="null"; out=[]
            while True:
              r = sh("gh","api","graphql","-f",f"query={q}","-F",f"owner={owner}","-F",f"name={name}","-F",f"after={after}")
              if r.returncode!=0: break
              data=json.loads(r.stdout)
              nodes=((data.get("data") or {}).get("repository") or {}).get("vulnerabilityAlerts",{}).get("nodes",[])
              for n in nodes:
                sv=n.get("securityVulnerability") or {}
                sev=sv.get("severity")
                if rscore(sev)<min_r: continue
                pkg=(sv.get("package") or {})
                out.append({
                  "dependency":{
                    "package":{"name":pkg.get("name") or "","ecosystem":(pkg.get("ecosystem") or "").lower()},
                    "manifest_path":n.get("vulnerableManifestPath") or ""
                  },
                  "security_advisory":{"ghsa_id":(sv.get("advisory") or {}).get("ghsaId") or "","severity":sev},
                  "severity":sev,
                  "state":"open",
                  "html_url": None
                })
              pi=((data.get("data") or {}).get("repository") or {}).get("vulnerabilityAlerts",{}).get("pageInfo",{})
              if not pi.get("hasNextPage"): break
              after=json.dumps(pi.get("endCursor"))
            return out

            # end

          alerts = try_rest("open") or try_rest("all") or try_graphql()
          with open("triage/alerts.json","w",encoding="utf-8") as f: json.dump(alerts,f)
          print(f"fetched alerts: {len(alerts)} >= severity {MIN} for {REPO}")
          PY

      - name: Classify & intersect (dev/runtime, used/unused)
        shell: bash
        run: |
          set -euo pipefail
          python << 'PY'
          import os, json, pathlib, re

          alerts = json.load(open("triage/alerts.json","r",encoding="utf-8"))
          tri = pathlib.Path("triage")
          sub = tri / "sub"
          # Aggregate per eco → used/unused sets
          node_used=set()
          node_unused=set()
          py_extra=set()
          comp_unused=set()
          mvn_unused=set()

          for p in sub.glob("*_node_used.txt"):
            node_used |= set(x.strip() for x in p.read_text().splitlines() if x.strip())
          for p in sub.glob("*_node_unused.txt"):
            node_unused |= set(x.strip() for x in p.read_text().splitlines() if x.strip())
          for p in sub.glob("*_py_extra.txt"):
            py_extra |= set(x.strip() for x in p.read_text().splitlines() if x.strip())
          for p in sub.glob("*_comp_unused.txt"):
            comp_unused |= set(x.strip() for x in p.read_text().splitlines() if x.strip())
          for p in sub.glob("*_mvn_unused.txt"):
            mvn_unused |= set(x.strip() for x in p.read_text().splitlines() if x.strip())

          def sev(a):
            return (a.get("security_advisory") or {}).get("severity") or a.get("severity") or ""

          def is_dev(eco, manifest):
            m=(manifest or "").lower()
            if eco in ("npm","pnpm","yarn"):
              return "test" in m or "examples" in m or m.endswith("package.json") and "dev" in m
            if eco in ("pip","pypi"):
              return "test" in m or "dev" in m or "docs" in m
            if eco in ("composer",):
              return "test" in m or "dev" in m
            if eco in ("maven","gradle"):
              return "test" in m
            return False

          kept=[]; ignored=[]
          for a in alerts:
            dep = a.get("dependency") or {}
            pkginfo = dep.get("package") or {}
            pkg = pkginfo.get("name") or ""
            eco = (pkginfo.get("ecosystem") or "").lower()
            manifest = dep.get("manifest_path") or ""
            used=False

            if eco in ("npm","pnpm","yarn"):
              used = pkg in node_used
              unused_hit = (pkg in node_unused)
            elif eco in ("pip","pypi"):
              # Wenn in extra-Liste → explizit unbenutzt
              unused_hit = (pkg in py_extra)
              used = not unused_hit
            elif eco in ("composer",):
              unused_hit = (pkg in comp_unused)
              used = not unused_hit
            elif eco in ("maven", "gradle"):
              unused_hit = (pkg in mvn_unused)  # heuristisch
              used = not unused_hit
            else:
              unused_hit = False

            row = {
              "package": pkg,
              "ecosystem": eco,
              "severity": sev(a),
              "manifest": manifest,
              "url": a.get("html_url") or "",
              "dev": "yes" if is_dev(eco, manifest) else "no",
              "used": "yes" if used else "no"
            }

            if not used or unused_hit:
              row["reason"]="unused"
              ignored.append(row)
            elif row["dev"]=="yes" and row["severity"].lower() not in ("critical","high"):
              row["reason"]="dev-noncritical"
              ignored.append(row)
            else:
              kept.append(row)

          (tri / "kept.json").write_text(json.dumps(kept, indent=2, ensure_ascii=False), encoding="utf-8")
          (tri / "ignored.json").write_text(json.dumps(ignored, indent=2, ensure_ascii=False), encoding="utf-8")
          PY

      - name: Build report
        id: report
        shell: bash
        run: |
          set -euo pipefail
          kept_n=$(jq 'length' triage/kept.json 2>/dev/null || echo 0)
          ign_n=$(jq 'length' triage/ignored.json 2>/dev/null || echo 0)

          {
            echo "### Dependabot Auto-Triage – ${REPO}"
            echo
            echo "**Alerts (gefiltert nach min_severity=${{ inputs.min_severity }}):** kept=${kept_n}, ignored=${ign_n}"
            echo
            echo "#### ⚠️ Kandidaten zum Entfernen (unused ∩ alerts / dev-noncritical)"
            jq -r '.[] | "- `\(.ecosystem):\(.package)` (sev: \(.severity), dev: \(.dev), used: \(.used)) \(.manifest)"' triage/ignored.json || true
            echo
            echo "#### ✅ Relevante Alerts (bleiben offen)"
            jq -r '.[] | "- `\(.ecosystem):\(.package)` (sev: \(.severity), dev: \(.dev), used: \(.used)) \(.manifest)"' triage/kept.json || true
          } | tee triage/report.md

      - name: Comment to PR (if PR)
        if: ${{ github.event_name == 'pull_request' }}
        uses: thollander/actions-comment-pull-request@v2
        with:
          filePath: triage/report.md

      - name: Mirror kept alerts to Issues (dedup)
        env:
          DEST_REPO: ${{ env.REPO }}
        shell: bash
        run: |
          set -euo pipefail
          python << 'PY'
          import json, os, subprocess, hashlib

          dest = os.environ.get("DEST_REPO","")
          kept = json.load(open("triage/kept.json","r",encoding="utf-8"))

          def sh(*args):
              return subprocess.run(args, capture_output=True, text=True)

          for r in kept:
              key = f"{dest}|{r.get('ecosystem')}|{r.get('package')}|{r.get('severity')}|{r.get('manifest')}"
              slug = hashlib.sha1(key.encode()).hexdigest()[:10]
              title = f"[Dependabot Triage] {r.get('ecosystem')}:{r.get('package')} ({r.get('severity')}) [{slug}]"
              scope = "dev" if r.get("dev")=="yes" else "runtime/unknown"
              body = (
                  "Automatische Triage – Alert bleibt offen (kein Dismiss).\n\n"
                  f"- **Repo**: {dest}\n"
                  f"- **Paket**: `{r.get('package','')}` ({r.get('ecosystem','')})\n"
                  f"- **Severity**: {r.get('severity','')}\n"
                  f"- **Scope**: {scope}\n"
                  f"- **Used**: {r.get('used','')}\n"
                  f"- **Manifest**: {r.get('manifest','')}\n"
                  f"- **Alert**: {r.get('url','')}\n"
              )
              labels = ["security","dependabot","needs-triage"]
              labels.append("dev" if scope=="dev" else "runtime")

              lst = sh("gh","issue","list","-R",dest,"--search",title,"--json","number,title")
              try:
                  existing = [i["title"] for i in json.loads(lst.stdout or "[]")]
              except Exception:
                  existing = []
              if title not in existing:
                  sh("gh","issue","create","-R",dest,"--title",title,"--body",body,"--label",",".join(labels))
          PY

      - name: Sanitize artifact name
        id: sanitize
        shell: bash
        run: |
          SAFE_NAME="$(echo "${REPO}" | tr '/' '-')"
          echo "safe=${SAFE_NAME}" >> $GITHUB_OUTPUT

      - name: Upload triage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: triage-${{ steps.sanitize.outputs.safe }}
          path: triage/**

      - name: Fail on intersections (policy)
        if: ${{ inputs.fail_on_intersection == true }}
        shell: bash
        run: |
          # Fail, wenn es überhaupt ignorierte (unused/dev-noncritical) Alerts gibt
          cnt=$(jq 'length' triage/ignored.json 2>/dev/null || echo 0)
          if [ "$cnt" -gt 0 ]; then
            echo "Unused/dev-noncritical Alerts vorhanden ($cnt). Policy verlangt Fail."
            exit 1
          fi

